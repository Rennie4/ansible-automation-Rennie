---
- name: AWS Infrastructure - Create and Attach
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    # Hardcoded region to prevent survey recursion loops
    aws_region: "eu-west-1"
    
    # These map directly to your AAP Survey variables
    aws_instance: "{{ target_instance_id }}"
    aws_size: "{{ target_vol_size }}"
    aws_zone: "{{ target_zone }}"

  tasks:
    - name: Create and Attach EBS Volume
      amazon.aws.ec2_vol:
        instance: "{{ aws_instance }}"
        region: "{{ aws_region }}"
        zone: "{{ aws_zone }}"
        volume_size: "{{ aws_size }}"
        device_name: /dev/sdf
        state: present
      register: ec2_vol_result

    - name: Set facts for OS discovery
      set_fact:
        # Pass the AWS Volume ID and requested Size to the next play
        vol_id_short: "{{ ec2_vol_result.volume_id | replace('-', '') }}"
        survey_size: "{{ aws_size }}"

- name: OS Configuration - Universal Format and Mount
  hosts: linux_hosts
  become: yes
  tasks:
    - name: Set Filesystem Type based on OS Family
      set_fact:
        # Automatically chooses XFS for RedHat/AmazonLinux, Ext4 for Ubuntu/Debian
        preferred_fs: "{{ 'xfs' if ansible_os_family == 'RedHat' else 'ext4' }}"

    - name: Install required tools
      package:
        name:
          - util-linux
          - "{{ 'xfsprogs' if ansible_os_family == 'RedHat' else 'e2fsprogs' }}"
        state: present
      ignore_errors: true

    - name: Universal Device Discovery
      shell: 
        cmd: |
          # 1. Force Kernel to scan for new hardware (Essential for AWS)
          for bus in /sys/class/scsi_host/host*/scan; do echo "- - -" > "$bus"; done
          udevadm settle
          sleep 2

          # 2. Search by AWS Hardware Serial (Most accurate for Nitro/Modern instances)
          SERIAL_ID="{{ hostvars['localhost']['vol_id_short'] }}"
          DEVICE=$(lsblk -rdpno NAME,SERIAL | grep "$SERIAL_ID" | awk '{print $1}' | head -n 1)
          
          # 3. Fallback: Search by "Fuzzy" Size (Best for Legacy/T2/Xen instances)
          if [ -z "$DEVICE" ]; then
            # Identify root disk to exclude it from formatting
            ROOT_PART=$(findmnt -no SOURCE / | head -n 1)
            ROOT_DISK=$(lsblk -no PKNAME "$ROOT_PART" | head -n 1)
            [ -z "$ROOT_DISK" ] && ROOT_DISK=$(basename "$ROOT_PART")
            
            # Convert requested GB to bytes and look for a disk within 0.5GB range
            TARGET_BYTES=$(( {{ hostvars['localhost']['survey_size'] }} * 1024 * 1024 * 1024 ))
            MIN_BYTES=$(( $TARGET_BYTES - 536870912 )) 
            MAX_BYTES=$(( $TARGET_BYTES + 536870912 )) 

            DEVICE=$(lsblk -dpbno NAME,SIZE | awk -v min="$MIN_BYTES" -v max="$MAX_BYTES" -v root="$ROOT_DISK" \
              '$2 >= min && $2 <= max && $1 !~ root {print $1}' | head -n 1)
          fi
          
          echo "$DEVICE"
      register: found_device
      failed_when: found_device.stdout == ""

    - name: Format and Mount
      vars:
        final_dev: "{{ found_device.stdout }}"
      block:
        - name: Create mount directory
          file:
            path: /data
            state: directory
            mode: '0755'

        - name: Create filesystem
          filesystem:
            fstype: "{{ preferred_fs }}"
            dev: "{{ final_dev }}"
            force: no

        - name: Mount volume by UUID (Persistent)
          mount:
            path: /data
            src: "{{ final_dev }}"
            fstype: "{{ preferred_fs }}"
            state: mounted
            opts: defaults

    - name: Final Verification
      shell: "df -h | grep /data"
      register: final_status

    - name: Success Message
      debug:
        msg: "Success! Disk mounted on {{ found_device.stdout }}: {{ final_status.stdout }}"
