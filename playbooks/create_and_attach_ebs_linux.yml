
---
# Play 1: AWS actions on localhost
- name: AWS Infrastructure - Create and Attach Multiple Volumes
  hosts: localhost
  connection: local
  gather_facts: true

  vars:
    # --- Survey vars ---
    aws_instance: "{{ target_instance_id }}"
    aws_region: "{{ target_region | default('eu-west-1') }}"
    target_az: "{{ target_availability_zone | default('') }}"

    # Prefer CSV; if omitted, use single size + count
    sizes_csv: "{{ target_volume_sizes_csv | default('') }}"
    single_size: "{{ target_vol_size | default(omit) }}"
    single_count: "{{ target_volume_count | default(omit) }}"

    fstype: "{{ target_fstype | default('ext4') }}"
    volume_type: "{{ target_volume_type | default('gp3') }}"
    delete_on_termination: "{{ target_delete_on_termination | default(false) | bool }}"
    encrypted: "{{ target_encrypted | default(true) | bool }}"
    kms_key_id: "{{ target_kms_key_id | default(omit) }}"
    iops: "{{ target_iops | default(omit) }}"
    throughput: "{{ target_throughput | default(omit) }}"

    # Candidate API device labels (/dev/sdf, /dev/sdg, ...) â€” OS will expose nvme devices on Nitro
    attach_device_prefix: "/dev/sd"
    candidate_letters: ['f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u']

  tasks:
    # ---------- Credential & input prechecks ----------
    - name: Precheck - AWS env vars injected
      assert:
        that:
          - lookup('env', 'AWS_ACCESS_KEY_ID') | length > 0
          - lookup('env', 'AWS_SECRET_ACCESS_KEY') | length > 0
        fail_msg: >-
          AWS credentials not found in environment. Ensure the Job Template has an
          'Amazon Web Services' credential attached and the Execution Environment
          includes boto3/botocore and amazon.aws collection.

    - name: Normalize region from env if blank
      set_fact:
        aws_region: "{{ aws_region if aws_region|length>0 else (lookup('env', 'AWS_DEFAULT_REGION') | default('eu-west-1')) }}"

    - name: STS caller identity (sanity check)
      amazon.aws.aws_caller_info:
        region: "{{ aws_region }}"
      register: whoami

    - name: Validate instance id presence
      assert:
        that:
          - aws_instance is match('^i-[0-9a-f]+$')
        fail_msg: "Survey validation failed: instance_id (i-xxxx) is required."

    # ---------- Build sizes list from CSV OR single size + count ----------
    - name: When CSV provided, parse sizes
      set_fact:
        sizes_list: "{{ sizes_csv | trim | split(',') | map('trim') | list }}"
        sizes_int_list: "{{ sizes_csv | trim | split(',') | map('trim') | map('int') | list }}"
      when: sizes_csv | trim | length > 0

    - name: When CSV missing, derive list from single size + count
      set_fact:
        sizes_int_list: "{{ range(0, single_count | int) | map('int') | map('regex_replace', '.*', single_size | string) | map('int') | list }}"
      when: sizes_csv | trim | length == 0 and single_size is defined and single_count is defined

    - name: Validate we have a non-empty sizes list
      assert:
        that:
          - sizes_int_list | length > 0
          - (sizes_int_list | min) > 0
        fail_msg: >-
          Provide either 'target_volume_sizes_csv' (e.g., 20,30,50) OR both
          'target_vol_size' and 'target_volume_count' (e.g., size=20, count=3).

    # ---------- Discover instance & effective AZ ----------
    - name: Get instance details
      amazon.aws.ec2_instance_info:
        region: "{{ aws_region }}"
        instance_ids: ["{{ aws_instance }}"]
      register: instance_info

    - name: Fail if instance not found
      assert:
        that:
          - instance_info.instances | length == 1
        fail_msg: "Instance {{ aws_instance }} not found in region {{ aws_region }}."

    - name: Set instance facts and effective zone
      set_fact:
        instance_zone: "{{ instance_info.instances[0].placement.availability_zone }}"
        aws_zone: >-
          {{ (target_az | length > 0)
             | ternary(target_az, instance_info.instances[0].placement.availability_zone) }}
        target_ip: >-
          {{ instance_info.instances[0].public_ip_address
             if instance_info.instances[0].public_ip_address
             else instance_info.instances[0].private_ip_address }}
        existing_device_names: "{{ instance_info.instances[0].block_device_mappings | map(attribute='device_name') | list }}"

    - name: Assert zone matches
      assert:
        that:
          - aws_zone == instance_zone
        fail_msg: "AZ mismatch: selected {{ aws_zone }} vs instance {{ instance_zone }}."

    - name: Compute free device labels (avoid collisions)
      set_fact:
        used_letters: >-
          {{ existing_device_names
             | map('regex_search', '^/dev/sd([a-z]+)$')
             | map('last')
             | select('string')
             | list }}
        free_letters: "{{ candidate_letters | difference(used_letters) }}"

    - name: Validate we have enough free labels
      assert:
        that:
          - free_letters | length >= (sizes_int_list | length)
        fail_msg: >-
          Not enough free device labels. Used: {{ used_letters }}; Available: {{ free_letters }}.
          Reduce count or detach existing volumes.

    - name: Debug - Plan
      debug:
        msg:
          - "Account: {{ whoami.account }}"
          - "Instance: {{ aws_instance }}"
          - "Region: {{ aws_region }}"
          - "AZ (effective): {{ aws_zone }}"
          - "Requested sizes (GiB): {{ sizes_int_list }}"
          - "Existing device names: {{ existing_device_names }}"
          - "Free letters (to use): {{ free_letters[:(sizes_int_list | length)] }}"

    # ---------- Create volumes ----------
    - name: Create EBS volumes
      amazon.aws.ec2_vol:
        region: "{{ aws_region }}"
        zone: "{{ aws_zone }}"
        volume_size: "{{ item }}"
        volume_type: "{{ volume_type }}"
        iops: "{{ iops }}"
        throughput: "{{ throughput }}"
        encrypted: "{{ encrypted }}"
        kms_key_id: "{{ kms_key_id }}"
        tags:
          Name: "Reusable-Disk-{{ aws_instance }}-{{ item }}GiB-{{ ansible_date_time.epoch }}"
          Owner: "{{ lookup('env', 'USER') | default('awx') }}"
          ManagedBy: "Ansible"
          InstanceId: "{{ aws_instance }}"
          Region: "{{ aws_region }}"
          SizeGB: "{{ item }}"
        state: present
      loop: "{{ sizes_int_list }}"
      loop_control:
        index_var: idx
        label: "{{ item }} GiB"
      register: create_results

    - name: Ensure all volumes created
      assert:
        that:
          - create_results.results | length == (sizes_int_list | length)
          - (create_results.results | map(attribute='volume_id') | list | select('string') | length) == (sizes_int_list | length)
        fail_msg: "One or more volumes were not created (missing volume_id)."

    # ---------- Attach volumes ----------
    - name: Attach new volumes to instance
      amazon.aws.ec2_vol:
        region: "{{ aws_region }}"
        instance: "{{ aws_instance }}"
        volume_id: "{{ vol_res.volume_id }}"
        device_name: "{{ attach_device_prefix }}{{ free_letters[idx] }}"
        delete_on_termination: "{{ delete_on_termination }}"
        state: present
      loop: "{{ range(0, create_results.results | length) | zip(create_results.results) | list }}"
      vars:
        idx: "{{ item.0 }}"
        vol_res: "{{ item.1 }}"
      loop_control:
        label: "vol={{ vol_res.volume_id }} -> {{ attach_device_prefix }}{{ free_letters[idx] }}"
      register: attach_results

    # ---------- Wait attachments ----------
    - name: Wait until each volume is attached
      amazon.aws.ec2_vol_info:
        region: "{{ aws_region }}"
        filters:
          volume-id: "{{ vol_res.volume_id }}"
      loop: "{{ range(0, create_results.results | length) | zip(create_results.results) | list }}"
      vars:
        idx: "{{ item.0 }}"
        vol_res: "{{ item.1 }}"
      register: wait_info
      until:
        - wait_info.volumes is defined
        - wait_info.volumes | length > 0
        - wait_info.volumes[0].attachment_set | length > 0
        - wait_info.volumes[0].attachment_set[0].instance_id == aws_instance
        - wait_info.volumes[0].attachment_set[0].status in ['attaching', 'attached']
      retries: 30
      delay: 5

    # ---------- Collect created volume metadata ----------
    - name: Build created_volumes list
      set_fact:
        created_volumes: []
    - name: Append created volumes metadata
      set_fact:
        created_volumes: "{{ created_volumes + [ { 'index': idx, 'size_gb': sizes_int_list[idx], 'volume_id': create_results.results[idx].volume_id } ] }}"
      loop: "{{ range(0, create_results.results | length) | list }}"
      loop_control:
        index_var: idx

    - name: Debug - Created volumes
      debug:
        var: created_volumes

    # ---------- Dynamic inventory for OS config ----------
    - name: Add target host for OS config
      add_host:
        name: "current_target"
        ansible_host: "{{ target_ip }}"
        ansible_user: "ubuntu"
        ansible_ssh_private_key_file: "{{ lookup('env', 'ANSIBLE_PRIVATE_KEY_FILE') | default('/runner/artifacts/{{ ansible_job_id }}/ssh_key_data') }}"
        groups: active_nodes
      vars:
        created_volumes: "{{ created_volumes }}"
        fstype: "{{ fstype }}"

# Play 2: OS actions on the instance
- name: OS Configuration - Format and Mount Multiple Volumes
  hosts: active_nodes
  gather_facts: no

  tasks:
    - name: Wait for SSH
      wait_for:
        port: 22
        host: "{{ ansible_host }}"
        search_regex: OpenSSH
        timeout: 300
      delegate_to: localhost

    - name: Debug - Volumes to configure
      debug:
        var: hostvars['localhost']['created_volumes']

    # Per-volume NVMe detection with internal retry loop (avoids Ansible 'until' + loop quirks)
    - name: Find device by EBS serial (Nitro/NVMe friendly)
      become: yes
      shell: |
        set -euo pipefail
        VOLNOHYP="{{ item.volume_id | replace('-', '') }}"
        for i in $(seq 1 20); do
          DEV="$(lsblk -rdpno NAME,SERIAL | awk -v v="$VOLNOHYP" '$2 == v {print $1; exit}')"
          if [ -z "$DEV" ]; then
            DEV="$(ls -1 /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_vol* 2>/dev/null | head -n1)"
            [ -n "$DEV" ] && DEV="$(readlink -f "$DEV")"
          fi
          if [ -n "$DEV" ]; then echo -n "$DEV"; exit 0; fi
          sleep 5
        done
        exit 1
      loop: "{{ hostvars['localhost']['created_volumes'] }}"
      register: found_device
      args:
        executable: /bin/bash

    - name: Detect filesystem on each device
      become: yes
      command: lsblk -no FSTYPE "{{ item.stdout }}"
      loop: "{{ found_device.results }}"
      register: fs_detect

    - name: Create mount directories
      become: yes
      file:
        path: "/data_{{ item.item.size_gb }}gb_{{ item.item.volume_id[-4:] }}"
        state: directory
        mode: '0755'
      loop: "{{ found_device.results }}"

    - name: Create filesystem if none
      become: yes
      filesystem:
        fstype: "{{ hostvars['localhost']['fstype'] }}"
        dev: "{{ item.0.stdout }}"
      loop: "{{ range(0, found_device.results | length) | zip(found_device.results, fs_detect.results) | list }}"
      when: item.1.stdout | trim == ""

    - name: Mount filesystems
      become: yes
      mount:
        path: "/data_{{ item.item.size_gb }}gb_{{ item.item.volume_id[-4:] }}"
        src: "{{ item.stdout }}"
        fstype: "{{ hostvars['localhost']['fstype'] }}"
        state: mounted
      loop: "{{ found_device.results }}"
