
---
# File: create_and_attach_ebs_single.yml
# Purpose: Create and attach ONE EBS volume to a Linux EC2 instance (survey-driven), then optionally format & mount.

# Play 1: AWS actions (create + attach)
- name: AWS Infrastructure - Create and Attach ONE EBS Volume
  hosts: localhost
  connection: local
  gather_facts: true

  vars:
    # ===== Survey / extra vars (AWX prompts) =====
    aws_instance: "{{ target_instance_id }}"
    aws_size: "{{ target_vol_size | int }}"
    aws_region: "{{ target_region | default('eu-west-1') }}"
    target_az: "{{ target_availability_zone | default('') }}"

    # Optional tuning
    volume_type: "{{ target_volume_type | default('gp3') }}"
    encrypted: "{{ target_encrypted | default(true) | bool }}"
    kms_key_id: "{{ target_kms_key_id | default(omit) }}"
    delete_on_termination: "{{ target_delete_on_termination | default(false) | bool }}"
    iops: "{{ target_iops | default(omit) }}"
    throughput: "{{ target_throughput | default(omit) }}"

    # Optional OS step toggle (format & mount). Keep false for infra-only.
    do_mount: "{{ target_do_mount | default(false) | bool }}"
    fstype: "{{ target_fstype | default('ext4') }}"

    # Candidate device labels for AWS API (OS will expose nvme devices on Nitro)
    attach_device_prefix: "/dev/sd"
    candidate_letters: ['f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u']

  tasks:
    # ---------- Prechecks ----------
    - name: Precheck - AWS credentials injected (AWX Amazon Web Services credential or env vars)
      assert:
        that:
          - lookup('env', 'AWS_ACCESS_KEY_ID') | length > 0
          - lookup('env', 'AWS_SECRET_ACCESS_KEY') | length > 0
        fail_msg: >-
          AWS credentials not found. Attach an 'Amazon Web Services' credential to the Job Template
          or export AWS_* env vars in the Execution Environment.

    - name: Normalize region from env if blank
      set_fact:
        aws_region: "{{ aws_region if aws_region|length>0 else (lookup('env', 'AWS_DEFAULT_REGION') | default('eu-west-1')) }}"

    - name: Validate instance id and size (GiB)
      assert:
        that:
          - aws_instance is match('^i-[0-9a-f]+$')
          - aws_size | int > 0
        fail_msg: "Validation failed: instance_id (i-xxxx) and size (>0 GiB) are required."

    # ---------- Discover instance & effective AZ ----------
    - name: Get instance details
      amazon.aws.ec2_instance_info:
        region: "{{ aws_region }}"
        instance_ids: ["{{ aws_instance }}"]
      register: instance_info

    - name: Fail if instance not found
      assert:
        that:
          - instance_info.instances | length == 1
        fail_msg: "Instance {{ aws_instance }} not found in region {{ aws_region }}."

    - name: Set instance facts and effective zone (use survey AZ, else instance AZ)
      set_fact:
        instance_zone: "{{ instance_info.instances[0].placement.availability_zone }}"
        aws_zone: >-
          {{ (target_az | length > 0)
             | ternary(target_az, instance_info.instances[0].placement.availability_zone) }}
        existing_device_names: "{{ instance_info.instances[0].block_device_mappings | map(attribute='device_name') | list }}"
        target_ip: >-
          {{ instance_info.instances[0].public_ip_address
             if instance_info.instances[0].public_ip_address
             else instance_info.instances[0].private_ip_address }}

    - name: Assert zone matches instance AZ (AWS requires same AZ to attach)
      assert:
        that:
          - aws_zone == instance_zone
        fail_msg: >-
          AZ mismatch: selected AZ ({{ aws_zone }}) != instance AZ ({{ instance_zone }}).
          EBS volumes must be created in the SAME AZ as the instance.

    # ---------- Pick a safe API device label (avoid collisions like /dev/sda1, /dev/sdp) ----------
    - name: Normalize device names list (keep only strings)
      set_fact:
        existing_device_names_clean: "{{ existing_device_names | select('string') | list }}"

    - name: Extract used /dev/sd* LETTERS (ignore digits and non-sd devices)
      set_fact:
        used_letters: >-
          {{ existing_device_names_clean
             | map('regex_replace', '^/dev/sd([a-z]+)[0-9]*$', '\\1')
             | select('match', '^[a-z]+$')
             | list }}

    - name: Compute free letters (candidates minus used)
      set_fact:
        free_letters: "{{ candidate_letters | difference(used_letters) }}"

    - name: Ensure at least one free label is available
      assert:
        that:
          - free_letters | length > 0
        fail_msg: >-
          No free device labels available. Used letters: {{ used_letters }}.
          Existing device names: {{ existing_device_names_clean }}.

    - name: Pick first free label
      set_fact:
        attach_label: "{{ attach_device_prefix }}{{ free_letters[0] }}"

    - name: Debug - Plan
      debug:
        msg:
          - "Instance: {{ aws_instance }}"
          - "Region: {{ aws_region }}"
          - "AZ (effective): {{ aws_zone }}"
          - "Requested size (GiB): {{ aws_size }}"
          - "Attach label (API): {{ attach_label }}"

    # ---------- Create the volume (same AZ as instance) ----------
    - name: Create EBS volume
      amazon.aws.ec2_vol:
        region: "{{ aws_region }}"
        zone: "{{ aws_zone }}"
        volume_size: "{{ aws_size }}"
        volume_type: "{{ volume_type }}"
        iops: "{{ iops }}"
        throughput: "{{ throughput }}"
        encrypted: "{{ encrypted }}"
        kms_key_id: "{{ kms_key_id }}"
        tags:
          Name: "Reusable-Disk-{{ aws_instance }}-{{ aws_size }}GiB-{{ ansible_date_time.epoch }}"
          ManagedBy: "Ansible"
          InstanceId: "{{ aws_instance }}"
          Region: "{{ aws_region }}"
          SizeGB: "{{ aws_size }}"
        state: present
      register: raw_vol

    - name: Ensure volume was created
      assert:
        that:
          - raw_vol.volume_id is defined
        fail_msg: "EBS volume creation failed—no volume_id returned. Check IAM/KMS permissions."

    - name: Debug - Created volume
      debug:
        msg:
          - "Volume ID: {{ raw_vol.volume_id }}"
          - "Console tip: EC2 > Volumes (Region={{ aws_region }}) — filter by ID or Tag 'ManagedBy=Ansible'"

    # ---------- Attach to the instance ----------
    - name: Attach EBS volume to instance
      amazon.aws.ec2_vol:
        region: "{{ aws_region }}"
        instance: "{{ aws_instance }}"
        volume_id: "{{ raw_vol.volume_id }}"
        device_name: "{{ attach_label }}"
        delete_on_termination: "{{ delete_on_termination }}"
        state: present
      register: attach_result

    - name: Wait until attached
      amazon.aws.ec2_vol_info:
        region: "{{ aws_region }}"
        filters:
          volume-id: "{{ raw_vol.volume_id }}"
      register: vol_info
      until:
        - vol_info.volumes | length > 0
        - vol_info.volumes[0].attachment_set | length > 0
        - vol_info.volumes[0].attachment_set[0].instance_id == aws_instance
        - vol_info.volumes[0].attachment_set[0].status in ['attaching', 'attached']
      retries: 30
      delay: 5

    - name: Summary - Creation & Attachment
      debug:
        msg:
          - "SUCCESS: Volume {{ raw_vol.volume_id }} ({{ aws_size }} GiB) created in {{ aws_zone }} and attached to {{ aws_instance }}."
          - "Attachment label (API): {{ attach_label }}"
          - "Note: On Nitro/Linux the OS device will likely be /dev/nvmeXnY (not {{ attach_label }})."

    # ---------- Optionally enable OS mount step ----------
    - name: Add target to dynamic inventory (for OS mount step)
      add_host:
        name: "current_target"
        ansible_host: "{{ target_ip }}"
        ansible_user: "ubuntu"
        ansible_ssh_private_key_file: "{{ lookup('env', 'ANSIBLE_PRIVATE_KEY_FILE') | default('/runner/artifacts/{{ ansible_job_id }}/ssh_key_data') }}"
        groups: active_nodes
      when: do_mount
      vars:
        raw_vol: "{{ raw_vol }}"
        aws_size: "{{ aws_size }}"
        fstype: "{{ fstype }}"

# Play 2: OS actions (optional format & mount on Linux)
- name: OS Configuration - Format and Mount (NVMe/Nitro-safe)
  hosts: active_nodes
  gather_facts: no
  tasks:
    - name: Wait for SSH
      wait_for:
        port: 22
        host: "{{ ansible_host }}"
        search_regex: OpenSSH
        timeout: 300
      delegate_to: localhost

    - name: Find device by EBS serial (works for NVMe/Nitro)
      become: yes
      shell: |
        set -euo pipefail
        VOLNOHYP="{{ hostvars['localhost']['raw_vol']['volume_id'] | replace('-', '') }}"
        for i in $(seq 1 20); do
          DEV="$(lsblk -rdpno NAME,SERIAL | awk -v v="$VOLNOHYP" '$2 == v {print $1; exit}')"
          if [ -z "$DEV" ]; then
            DEV="$(ls -1 /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_vol* 2>/dev/null | head -n1)"
            [ -n "$DEV" ] && DEV="$(readlink -f "$DEV")"
          fi
          if [ -n "$DEV" ]; then echo -n "$DEV"; exit 0; fi
          sleep 5
        done
        exit 1
      register: found_device
      args:
        executable: /bin/bash

    - name: Detect existing filesystem
      become: yes
      command: lsblk -no FSTYPE "{{ found_device.stdout }}"
      register: fs_type

    - name: Create mount directory
      become: yes
      vars:
        mpath: "/data_{{ hostvars['localhost']['aws_size'] }}gb_{{ hostvars['localhost']['raw_vol']['volume_id'][-4:] }}"
      file:
        path: "{{ mpath }}"
        state: directory
        mode: '0755'

    - name: Create filesystem if none
      become: yes
      filesystem:
        fstype: "{{ hostvars['localhost']['fstype'] }}"
        dev: "{{ found_device.stdout }}"
      when: fs_type.stdout | trim == ""

    - name: Mount filesystem
      become: yes
      vars:
        mpath: "/data_{{ hostvars['localhost']['aws_size'] }}gb_{{ hostvars['localhost']['raw_vol']['volume_id'][-4:] }}"
      mount:
        path: "{{ mpath }}"
        src: "{{ found_device.stdout }}"
        fstype: "{{ hostvars['localhost']['fstype'] }}"
        state: mounted
``
