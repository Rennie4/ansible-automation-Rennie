---
- name: AWS Infrastructure - Resize Linux EBS Volume
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    region: "eu-west-1"
    volume_id: "{{ target_volume_id }}"
    new_size: "{{ target_new_size }}"

  tasks:
    - name: Get current volume info
      amazon.aws.ec2_vol_info:
        region: "{{ region }}"
        filters:
          volume-id: "{{ volume_id }}"
      register: vol_info

    - name: "Modify EBS volume {{ volume_id }} to {{ new_size }} GB"
      amazon.aws.ec2_vol:
        id: "{{ volume_id }}"
        volume_size: "{{ new_size }}"
        region: "{{ region }}"
        zone: "{{ vol_info.volumes[0].zone }}"
        modify_volume: true
      register: resize_result
      ignore_errors: yes 

    - name: Wait for AWS backend
      pause:
        seconds: 30
      when: resize_result.changed

- name: OS Configuration - Universal Multi-Distro Setup
  hosts: linux_hosts
  become: yes
  vars:
    vol_id_short: "{{ target_volume_id | replace('-', '') }}"
  tasks:
    - name: Ensure resize tools are present
      package:
        name: 
          - cloud-guest-utils
          - util-linux
        state: present
      ignore_errors: true

    - name: Universal Device Discovery and Resize
      shell: |
        # 1. FIND BY MOUNTPOINT (Most reliable for existing data disks)
        # findmnt returns the source device for a specific mount point
        DEVICE=$(findmnt -no SOURCE /data || findmnt -no SOURCE /mnt/data)

        # 2. FALLBACK: FIND BY SERIAL (Nitro instances)
        if [ -z "$DEVICE" ]; then
          DEVICE=$(lsblk -rdpno NAME,SERIAL | grep "{{ vol_id_short }}" | awk '{print $1}' | head -n 1)
        fi

        # 3. FALLBACK: FIND BY SIZE (New disks not yet mounted)
        if [ -z "$DEVICE" ]; then
          ROOT_DISK=$(lsblk -no PKNAME $(lsblk -no NAME,MOUNTPOINT | grep -w "/" | awk '{print $1}'))
          DEVICE=$(lsblk -rdpno NAME,SIZE | grep "{{ target_new_size }}G" | grep -v "$ROOT_DISK" | awk '{print $1}' | head -n 1)
        fi

        if [ -n "$DEVICE" ]; then
          # Get the parent disk name (e.g., if DEVICE is /dev/xvdf1, PARENT is xvdf)
          PARENT_NAME=$(lsblk -no PKNAME "$DEVICE")
          [ -z "$PARENT_NAME" ] && PARENT_NAME=$(basename "$DEVICE")

          # Refresh kernel hardware view
          echo 1 > "/sys/class/block/$PARENT_NAME/device/rescan"
          sleep 2
          
          echo "STATUS: Working on device $DEVICE"

          if ! blkid "$DEVICE"; then
              echo "STATUS: Blank disk. Initializing..."
              mkfs.ext4 -F "$DEVICE"
              mkdir -p /data
              mount "$DEVICE" /data
          else
              echo "STATUS: Existing data found. Resizing..."
              # Grow partition if it exists
              growpart "/dev/$PARENT_NAME" 1 || growpart "/dev/$PARENT_NAME" 2 || echo "Raw disk resize"
              
              # Perform the actual filesystem grow (Ext4 or XFS)
              resize2fs "$DEVICE" || xfs_growfs "$DEVICE" || xfs_growfs /data
          fi
          
          echo "TARGET_DEVICE: $DEVICE"
          df -h "$DEVICE"
        else
          echo "ERROR: Could not find disk by Mountpoint (/data), Serial, or Size"
          lsblk -f
          exit 1
        fi
      register: linux_resize_out

    - name: Report Final Status
      debug:
        msg: "{{ linux_resize_out.stdout_lines }}"
